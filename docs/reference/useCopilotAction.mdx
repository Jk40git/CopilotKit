---
title: "useCopilotAction"
description: "A hook for providing actions the Copilot can call."
---

<img
  referrerPolicy="no-referrer-when-downgrade"
  src="https://static.scarf.sh/a.png?x-pxid=a9b290bb-38f9-4518-ac3b-8f54fdbf43be"
/>

`useCopilotAction` is a React hook that lets you integrate
actionable functions in the Copilot chat. The Copilot can then call these
actions to trigger actions in your application, allowing for interactive
and dynamic behavior controlled by the Copilot.

You can define actions with parameters of any complexity. CopilotKit will relay
these definitions to the LLM and subsequently invoke your action handler with the
parameters you've defined.

In addition, the types of all parameters in your action handler are automatically
inferred from the action definition. This enables the use of TypeScript for
ensuring type safety and enabling autocompletion in your action handlers.

useCopilotAction takes an optional `render()` function that lets you render a
custom component or string instead of the default message component.

<RequestExample>
  ```jsx useCopilotAction Example
  useCopilotAction(
    {
      name: "sayHello",
      description: "Say hello to someone.",
      parameters: [
        {
          name: "name",
          type: "string",
          description: "name of the person to say greet",
        },
      ],
      handler: async ({name}) => {
        alert(`Hello, ${name}!`);
      },
    }
  );
````
</RequestExample>

## Parameters

<ResponseField name="action" type="Action" required>
  The function made available to the Copilot. See [Action](#action).
</ResponseField>

<ResponseField name="dependencies" type="any[]">
  An optional array of dependencies.
</ResponseField>

## Action

<ResponseField name="name" type="string" required>
  The name of the action.
</ResponseField>

<ResponseField name="description" type="string">
  A description of the action. This is used to instruct the Copilot on how to
  use the action.
</ResponseField>

<ResponseField name="parameters" type="Parameter[]">
  The parameters of the action. See [Parameter](#parameter).
</ResponseField>

<ResponseField name="handler" type="(args) => Promise<any>" required>
  The handler of the action.
</ResponseField>

<ResponseField name="render" type="function | string">
  Render lets you define a custom component or string to render instead of the
  default.

  #### Rendering a Waiting Message

  You might want to display a message to the user while they are waiting for an 
  action to complete. To do this, provide a string to `render`.
  
```js
{
  // ...
  render: "Processing...",
}
```

  This will display a spinner and the message "Processing..." while the action is
  running:

  <img src="/images/useCopilotAction/render-string.png" width="200" />

  When the action completes, the message will disappear.

  #### Rendering a Dynamic Message

  You can also provide a function to dynamically set the content of the message. This function will
  be called multiple times while the arguments are constructed and when the action is executed.

```js
{
  // ...
  render: ({ status, args, result }) => 
    (status === "complete" ? "☑️ Done!" : "Processing..."),
}
```

  The function will be called with `status`, `args`, and `result` properties.

  `status` can be one of the following values:
  - `"inProgress"`: The parameters of the action are being constructed by the language model.
    `args` are dynamically streamed to the function, allowing you to adjust your message in real-time.    
  - `"executing"`: The action handler is executing.
  - `"complete"`: The action handler has completed execution. `result` is the result of the action.

  `args` are the arguments passed to the action. When the status is `"inProgress"`, they are
  possibly incomplete.

  `result` is the result of the action. It is only available when the status is `"complete"`.
  
  If you want the message to disappear when the action is complete, return a falsy value. 
  Otherwise, return a string to display.

  <img src="/images/useCopilotAction/render-dynamic.png" width="200" />

  #### Generative UI

  Finally, you can return a React component instead of a string to render a custom component.

```js
{
  // ...
  render: ({status, args, result}) => (
    <div>
      {status === "complete" ? "Done!" : "Processing..."}
    </div>
  ),
}
```

  By using the streaming `args` parameter, you can create a generative UI that updates in real-time as 
  the arguments are being constructed.

  <div style={{display: "flex", justifyContent: "space-between"}}>
    <img src="/images/useCopilotAction/render-generative-spreadsheet.gif" width="200" />
    <img src="/images/useCopilotAction/render-generative-presentation.gif" width="200" />
  </div>


</ResponseField>

## Parameter

<ResponseField name="name" type="string" required>
  The name of the parameter.
</ResponseField>

<ResponseField
  name="type"
  type="'string' | 'number' | 'boolean' | 'object' | 'string[]' | 'number[]' | 'boolean[]' | 'object[]'"
  required
>
  The type of the argument.
</ResponseField>

<ResponseField name="description" type="string">
  A description of the argument. This is used to instruct the Copilot on what
  this argument is used for.
</ResponseField>

<ResponseField name="required" type="boolean">
  Wether or not the argument is required. Defaults to true.
</ResponseField>

<ResponseField name="attributes">
If the argument is of a complex type, i.e. `object` or `object[]`, this field
lets you define the attributes of the object. For example:
```js
{
  name: "addresses",
  description: "The addresses extracted from the text.",
  type: "object[]",
  attributes: [
    {
      name: "street",
      type: "string",
      description: "The street of the address.",
    },
    {
      name: "city",
      type: "string",
      description: "The city of the address.",
    },
    // ...
  ],
}
````
</ResponseField>
